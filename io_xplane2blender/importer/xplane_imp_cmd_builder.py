"""
Statefully builds OBJ commands, including animations and materials.

Takes in OBJ directives and their parameters and outputs at the end Blender datablocks
"""
import collections
import copy
import itertools
import math
import pathlib
import random
import re
from dataclasses import dataclass, field
from itertools import islice, tee
from pathlib import Path
from pprint import pprint
from typing import (
    Any,
    Callable,
    Deque,
    Dict,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
)

import bmesh
import bpy
from mathutils import Euler, Matrix, Quaternion, Vector

from io_xplane2blender.tests import test_creation_helpers
from io_xplane2blender.tests.test_creation_helpers import (
    AxisAngle,
    DatablockInfo,
    ParentInfo,
)
from io_xplane2blender.xplane_constants import (
    ANIM_TYPE_HIDE,
    ANIM_TYPE_SHOW,
    ANIM_TYPE_TRANSFORM,
    PRECISION_KEYFRAME,
)
from io_xplane2blender.xplane_helpers import (
    ExportableRoot,
    floatToStr,
    is_vector_axis_aligned,
    logger,
    round_vec,
    vec_b_to_x,
    vec_x_to_b,
)


@dataclass
class IntermediateDataref:
    """
    Matches xplane_props.XPlaneDataref.

    Made since dataclasses are more flexible then bpy.types.PropertyGroups.
    """

    anim_type: str = ANIM_TYPE_TRANSFORM
    loop: float = 0.0
    path: str = ""
    show_hide_v1: float = 0
    show_hide_v2: float = 0
    location_values: List[float] = field(default_factory=list)
    rotation_values: List[float] = field(default_factory=list)

    def __hash__(self):
        return hash(
            (
                self.anim_type,
                self.loop,
                self.path,
                self.show_hide_v1,
                self.show_hide_v2,
                tuple(self.location_values),
                tuple(self.rotation_values),
            )
        )


@dataclass
class IntermediateAnimation:
    """
    An animation is everything generated by one pair of ANIM_trans/rotate pair (or
    the static version). An IntermediateDatablock may have 0 or more of these.
    """

    # Blender Locations, pair with location_values
    # in xp_dataref
    locations: List[Vector] = field(default_factory=list)

    # Axis of rotations and the degrees of rotation along them.
    # - Will be empty, have 1 Off Axis Axis Angle, or 1 to 3 Axis Aligned Axis (
    # interpreted as a Euler)
    # - Must be paired with rotation_mode to have meaning
    # - Pairs perfectly with rotation_values in xp_dataref
    rotations: Dict[Vector, List[float]] = field(
        default_factory=lambda: collections.defaultdict(list)
    )
    xp_dataref: IntermediateDataref = field(
        default_factory=lambda: IntermediateDataref()
    )

    def apply_animation(self, bl_object: bpy.types.Object):
        """
        Applies any collected animations to a Blender Object
        """

        def recompose_rotation(
            rotation_mode: str, keyframe_idx: int
        ) -> Union[AxisAngle, Euler]:
            """
            Extract rotation at rotation keyframe idx,
            for use in KeyframeInfo.

            Rotations must be either
            - 1 AxisAngle
            - 1 to 3 axis that are all axis aligned
            - 1 to n axis that are not all axis aligned
            """
            if rotation_mode == "AXIS_ANGLE":
                axis, rotations = next(iter(self.rotations.items()))
                return AxisAngle(axis, math.radians(rotations[keyframe_idx]))
            else:

                def axis_to_label(axis):
                    r_axis = tuple(
                        map(lambda c: abs(int(round(c, PRECISION_KEYFRAME))), axis)
                    )
                    return {
                        (1, 0, 0): "X",
                        (0, 1, 0): "Y",
                        (0, 0, 1): "Z",
                    }[r_axis]

                # With this we become immune to any mutations to self.rotations order, but instead rely that
                # rotation_mode is absolutely right
                rotations = {
                    axis_to_label(axis): (axis, degrees)
                    for axis, degrees in self.rotations.items()
                }
                euler_components = {"X": 0, "Y": 0, "Z": 0}
                for axis_label, (axis, degrees) in rotations.items():
                    r_axis = tuple(
                        map(lambda c: bool(round(c, PRECISION_KEYFRAME)), axis)
                    )

                    # Remember, all axis are normalized, so we're okay
                    euler_components[axis_label] = axis[
                        r_axis.index(True)
                    ] * math.radians(degrees[keyframe_idx])

                tot_rot = Euler(euler_components.values(), rotation_mode)
                return tot_rot

        if self.xp_dataref.anim_type == ANIM_TYPE_TRANSFORM:
            keyframe_infos = []
            current_frame = 1
            for value_idx, value in enumerate(self.xp_dataref.location_values):
                keyframe_infos.append(
                    test_creation_helpers.KeyframeInfo(
                        idx=current_frame,
                        dataref_path=self.xp_dataref.path,
                        dataref_value=value,
                        dataref_loop=self.xp_dataref.loop,
                        dataref_anim_type=self.xp_dataref.anim_type,
                        location=self.locations[value_idx] + bl_object.location
                        if self.locations
                        else None,
                    )
                )
                current_frame += 1
            current_frame = 1
            for value_idx, value in enumerate(self.xp_dataref.rotation_values):
                keyframe_infos.append(
                    test_creation_helpers.KeyframeInfo(
                        idx=current_frame,
                        dataref_path=self.xp_dataref.path,
                        dataref_value=value,
                        dataref_loop=self.xp_dataref.loop,
                        dataref_anim_type=self.xp_dataref.anim_type,
                        location=None,
                        rotation=recompose_rotation(bl_object.rotation_mode, value_idx)
                        if self.rotations
                        else None,
                        rotation_mode=bl_object.rotation_mode,
                    )
                )
                current_frame += 1
        else:
            keyframe_infos = [
                test_creation_helpers.KeyframeInfo(
                    idx=1,
                    dataref_path=self.xp_dataref.path,
                    dataref_show_hide_v1=self.xp_dataref.show_hide_v1,
                    dataref_show_hide_v2=self.xp_dataref.show_hide_v2,
                    dataref_anim_type=self.xp_dataref.anim_type,
                )
            ]

        test_creation_helpers.set_animation_data(bl_object, keyframe_infos)
        current_frame = 1

    @property
    def is_animated_location(self) -> bool:
        return self.locations and self.xp_dataref.location_values

    @property
    def is_animated_rotation(self) -> bool:
        return self.rotations and self.xp_dataref.rotation_values

    """
    # Always
    # - You will have one of (type == "TRANSFORM" and (locations xor rotations) or (type == "SHOW"/"HIDE")
    # - locations cannot be "merged" for the same set of values, they are replaced instead, TODO: Is that true? "translations can dance around each other in each 'room'"
    # - All axis in rotations will be unit length
    # - locations and each axis's degrees list must equal the dataref's values list
    def is_valid_prior_optimization(self) -> bool:
        # - rotations will have a length of 0 or 1
        if self.xp_dataref.anim_type == ANIM_TYPE_TRANSFORM:
            exclusive_use = (self.locations and not self.rotations) or (
                not self.locations and self.rotations
            )
            # TODO: Support AngleAxis
            return exclusive_use and is_vector_axis_aligned(next(self.rotations
        else:
            return not self.locations and not self.rotations
    def is_valid_post_optimization(self)-> bool:
        # - rotations dict may have 0-3 entries, See doc for rotations according to rules of being AA or Euler
    """


@dataclass
class IntermediateDatablock:

    # You'll want to change this as little as possible.
    # If a property replacement exists, use it!
    #
    # DO NOT attempt to use .location or .rotation
    datablock_info: DatablockInfo

    # If Datablock is a MESH, these will correspond to (hopefully valid) entries in the idx table and _VT table
    start_idx: Optional[int]
    count: Optional[int]
    transform_animation: Optional[IntermediateAnimation]
    show_hide_animations: List[IntermediateAnimation]

    bake_matrix: Matrix

    # Why here? DatablockInfos are meant to be isolated structs as much as possible
    # and we're interested in the relationship between IntermediateDatablocks
    # and their animations which isn't data a DatablockInfo has
    children: List["IntermediateDatablock"] = field(default_factory=list)

    def build_mesh(self, vt_table: "VTTable") -> bpy.types.Mesh:
        """
        Builds a mesh from the OBJ's VT Table, raises ValueError if
        an object with that mesh couldn't be built
        """
        mesh_idxes = vt_table.idxes[self.start_idx : self.start_idx + self.count]

        vertex_map_old_to_new = {}
        vertices = []
        for idx in mesh_idxes:
            if idx not in vertex_map_old_to_new:
                vertices.append(vt_table.vertices[idx])
                vertex_map_old_to_new[idx] = len(vertices) - 1
            else:
                pass
        idxes = [vertex_map_old_to_new[idx] for idx in mesh_idxes]
        normals = [(v.nx, v.ny, v.nz) for v in vertices]
        uvs = [Vector((v.s, v.t)) for v in vertices]

        # Thanks senderle, https://stackoverflow.com/a/22045226
        def chunk(it, size):
            it = iter(it)
            return iter(lambda: tuple(itertools.islice(it, size)), ())

        py_vertices = [(v.x, v.y, v.z) for v in vertices]
        py_faces: List[Tuple[int, int, int]] = [
            # We reverse the winding order to reverse the faces
            face[::-1]
            for face in chunk(idxes, 3)
        ]

        me = bpy.data.meshes.new(self.name)
        me.from_pydata(py_vertices, [], py_faces)

        if not me.validate(verbose=True):
            # Thanks Dave Prue and their "Import X-Plane Object" addon for the API example
            me.uv_layers.new()

            for mesh_uv_loop, mesh_loop in zip(me.uv_layers[-1].data, me.loops):
                mesh_uv_loop.uv = uvs[mesh_loop.vertex_index]

            for i, vertex in enumerate(me.vertices):
                vertex.normal = normals[i]

            me.calc_normals()
            me.update(calc_edges=True)
            ob = test_creation_helpers.create_datablock_mesh(
                self.datablock_info,
                mesh_src=me,
            )

            return ob
        else:
            logger.error(
                f"Mesh was not valid, object '{self.name}' not made, check console for more"
            )
            raise ValueError

    @property
    def name(self) -> str:
        return self.datablock_info.name

    @property
    def parent(self) -> Optional[str]:
        try:
            return self.datablock_info.parent_info.parent
        except AttributeError:
            return None

    @parent.setter
    def parent(self, value: str) -> None:
        self.datablock_info.parent_info.parent = value

    @property
    def datablock_type(self) -> str:
        return self.datablock_info.datablock_type

    @property
    def is_animated(self) -> bool:
        return self.transform_animation or self.show_hide_animations

    @property
    def rotation_mode(self) -> str:
        """
        Calculates the final rotation_mode based on
        the back matrix and any animations it has.
        """
        # If its rotation or one of its animated rotations (if applicable)
        # is not axis_aligned, our Object will have Axis Angle rotation mode
        is_axis_aligned = is_vector_axis_aligned(
            self.bake_matrix.to_quaternion().to_axis_angle()[0]
        )
        if not self.transform_animation and is_axis_aligned:
            rotation_mode = "XYZ"
        elif not self.transform_animation and not is_axis_aligned:
            rotation_mode = "AXIS_ANGLE"
        # This is a very generalized check. See the rules for the rotations dict
        # in its definition
        elif any(
            not is_vector_axis_aligned(axis)
            for axis in self.transform_animation.rotations
        ):
            rotation_mode = "AXIS_ANGLE"
        else:
            # This is already figured out in finalize_intermediate_blocks
            rotation_mode = self.datablock_info.rotation_mode

        return rotation_mode


@dataclass
class VT:
    """Where xyz, nxyz are in Blender coords"""

    x: float
    y: float
    z: float
    nx: float
    ny: float
    nz: float
    s: float
    t: float

    def __post_init__(self):
        for attr, factory in type(self).__annotations__.items():
            try:
                setattr(self, attr, factory(getattr(self, attr)))
            except ValueError:
                print(
                    f"Couldn't convert '{attr}''s value ({getattr(self, attr)}) with {factory}"
                )

    def __str__(self) -> str:
        def fmt(s):
            try:
                return floatToStr(float(s))
            except (TypeError, ValueError):
                return s

        return "\t".join(
            fmt(value)
            for attr, value in vars(self).items()
            if not attr.startswith("__")
        )


@dataclass
class VTTable:
    vertices: List[VT] = field(default_factory=list)
    idxes: List[int] = field(default_factory=list)


@dataclass
class _AnimIntermediateStackEntry:
    animation: IntermediateAnimation
    intermediate_datablock: Optional[IntermediateDatablock]


class ImpCommandBuilder:
    def __init__(self, filepath: Path):
        self.root_collection = test_creation_helpers.create_datablock_collection(
            pathlib.Path(filepath).stem
        )

        self.root_collection.xplane.is_exportable_collection = True
        self.vt_table = VTTable([], [])
        self.texture: Optional[Path] = None
        # self.texture_lit:Optional[Path] = Path()
        # self.texture_normal:Optiona[Path] = Path()

        # Although we don't end up making this, it is useful for tree problems
        self.root_intermediate_datablock = IntermediateDatablock(
            datablock_info=DatablockInfo(
                datablock_type="EMPTY",
                name="INTER_ROOT",
                collection=self.root_collection,
            ),
            start_idx=None,
            count=None,
            transform_animation=None,
            show_hide_animations=[],
            bake_matrix=Matrix.Identity(4),
        )

        # --- Animation Builder States ----------------------------------------
        # Instead of build at separate parent/child relationship in Datablock info, we just save everything we make here
        self._blocks: List[IntermediateDatablock] = [self.root_intermediate_datablock]
        self._last_axis: Optional[Vector] = None
        self._anim_intermediate_stack: Deque[
            _AnimIntermediateStackEntry
        ] = collections.deque()
        self._anim_count: Sequence[int] = collections.deque()
        self._bake_matrix_stack: Deque[Matrix] = collections.deque((Matrix(),))
        # ---------------------------------------------------------------------

    def build_cmd(
        self, directive: str, *args: List[Union[float, int, str]], name_hint: str = ""
    ):
        """
        Given the directive and it's arguments, correctly handle each case.

        args must be every arg, in order, correctly typed, needed to build the command
        """

        def begin_new_frame() -> None:
            if not self._top_intermediate_datablock:
                parent = self.root_intermediate_datablock
            else:
                parent = self._top_intermediate_datablock

            empty = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    "EMPTY",
                    name=name_hint or self._next_empty_name(),
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.root_collection,
                ),
                start_idx=None,
                count=None,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=self._bake_matrix_stack[-1].copy(),
            )
            self._blocks.append(empty)
            parent.children.append(empty)

            self._anim_intermediate_stack.append(
                _AnimIntermediateStackEntry(IntermediateAnimation(), empty)
            )
            self._anim_count[-1] += 1
            empty.transform_animation = self._top_animation
            self._bake_matrix_stack[-1].identity()

        if directive == "VT":
            self.vt_table.vertices.append(VT(*args))
        elif directive == "IDX":
            self.vt_table.idxes.append(args[0])
        elif directive == "IDX10":
            # idx error etc
            self.vt_table.idxes.extend(args)
        elif directive == "TRIS":
            start_idx = args[0]
            count = args[1]
            if not self._anim_intermediate_stack:
                parent: IntermediateDatablock = self.root_intermediate_datablock
            else:
                parent: IntermediateDatablock = self._anim_intermediate_stack[
                    -1
                ].intermediate_datablock

            intermediate_datablock = IntermediateDatablock(
                datablock_info=DatablockInfo(
                    datablock_type="MESH",
                    name=name_hint or self._next_object_name(),
                    # How do we keep track of this
                    parent_info=ParentInfo(parent.datablock_info.name),
                    collection=self.root_collection,
                ),
                start_idx=start_idx,
                count=count,
                transform_animation=None,
                show_hide_animations=[],
                bake_matrix=self._bake_matrix_stack[-1].copy(),
            )
            self._blocks.append(intermediate_datablock)
            parent.children.append(intermediate_datablock)

        elif directive == "ANIM_begin":
            self._anim_count.append(0)
            self._bake_matrix_stack.append(self._bake_matrix_stack[-1].copy())
        elif directive == "ANIM_end":
            for i in range(self._anim_count.pop()):
                self._anim_intermediate_stack.pop()
            self._bake_matrix_stack.pop()
        elif directive == "ANIM_trans_begin":
            dataref_path = args[0]

            begin_new_frame()
            self._top_animation.xp_dataref = IntermediateDataref(
                anim_type=ANIM_TYPE_TRANSFORM,
                loop=0,
                path=dataref_path,
                show_hide_v1=0,
                show_hide_v2=0,
                location_values=[],
                rotation_values=[],
            )
        elif directive == "ANIM_trans_key":
            value = args[0]
            location = args[1]
            self._top_animation.locations.append(location)
            self._top_dataref.location_values.append(value)
        elif directive == "ANIM_trans_end":
            pass
        elif directive in {"ANIM_show", "ANIM_hide"}:
            v1, v2 = args[:2]
            dataref_path = args[2]
            begin_new_frame()
            self._top_dataref.anim_type = directive.replace("ANIM_", "")
            self._top_dataref.path = dataref_path
            self._top_dataref.show_hide_v1 = v1
            self._top_dataref.show_hide_v2 = v2
        elif directive == "ANIM_rotate_begin":
            axis = args[0]
            dataref_path = args[1]
            axis.normalize()

            self._last_axis = axis
            begin_new_frame()
            self._top_animation.xp_dataref = IntermediateDataref(
                anim_type=ANIM_TYPE_TRANSFORM,
                loop=0,
                path=dataref_path,
                show_hide_v1=0,
                show_hide_v2=0,
                location_values=[],
                rotation_values=[],
            )
        elif directive == "ANIM_rotate_key":
            value = args[0]
            degrees = args[1]
            self._top_animation.rotations[self._last_axis.freeze()].append(degrees)
            self._top_dataref.rotation_values.append(value)
        elif directive == "ANIM_rotate_end":
            self._last_axis = None
        elif directive == "ANIM_keyframe_loop":
            loop = args[0]
            self._top_dataref.loop = loop
        elif directive == "ANIM_trans":
            xyz1, xyz2 = args[0:2]
            v1, v2 = args[2:4]
            path = args[4]
            r_xyz1, r_xyz2 = (
                round_vec(xyz, PRECISION_KEYFRAME) for xyz in [xyz1, xyz2]
            )
            r_v1, r_v2 = (round(v, PRECISION_KEYFRAME) for v in [v1, v2])

            def add_as_dynamic():
                begin_new_frame()
                self._top_animation.locations.append(xyz1)
                self._top_animation.locations.append(xyz2)
                self._top_dataref.location_values.extend((v1, v2))
                self._top_dataref.path = path

            if r_xyz1 == r_xyz2 and r_v1 == r_v2:
                # print("trans, case A - static")
                self._bake_matrix_stack[-1] = self._bake_matrix_stack[
                    -1
                ] @ Matrix.Translation(xyz1)
            elif r_xyz1 == r_xyz2 and r_v1 != r_v2:
                # print("trans, case B - as dynamic")
                add_as_dynamic()
            elif r_xyz1 != r_xyz2 and r_v1 == r_v2:
                # print("trans, case C - as odd dynamic")
                add_as_dynamic()
                # TODO: make warning
                line = "bleh"
                logger.warn(
                    f"ANIM_trans"
                    f"    {c for c in xyz1}"
                    f"    {c for c in xyz2}"
                    f"    {v1} {v2} {path}`"
                    f"on line {line} has different locations but the same dataref values - it is malformed."
                    f"Fix {self._anim_intermediate_stack[-1].intermediate_datablock}"
                )
            elif r_xyz1 != r_xyz2 and r_v1 != r_v2:
                # print("trans, case D - dynamic")
                add_as_dynamic()

        elif directive == "ANIM_rotate":
            dxyz = args[0]
            r1, r2 = args[1:3]
            v1, v2 = args[3:5]
            path = args[5]

            dxyz.normalize()
            r_r1, r_r2 = (round(r, PRECISION_KEYFRAME) for r in [r1, r2])
            r_v1, r_v2 = (round(v, PRECISION_KEYFRAME) for v in [v1, v2])

            def add_as_dynamic():
                begin_new_frame()
                self._top_animation.rotations[dxyz.freeze()].append(r1)
                self._top_animation.rotations[dxyz.freeze()].append(r2)
                self._top_dataref.rotation_values.extend((v1, v2))
                self._top_dataref.path = path

            if r_r1 == r_r2 and r_v1 == r_v2:
                # print("rot, case A - static")
                self._bake_matrix_stack[-1] = (
                    self._bake_matrix_stack[-1]
                    @ Quaternion(dxyz, math.radians(r1)).to_matrix().to_4x4()
                )
                # print(
                #     "to euler in ANIM_rotate",
                #     [
                #         f"{math.degrees(c):.8f}"
                #         for c in self._bake_matrix_stack[-1].to_euler()
                #     ],
                # )
            elif r_r1 == r_r2 and r_v1 != r_v2:
                # print("rot, case B - as dynamic")
                add_as_dynamic()
            elif r_r1 != r_r2 and r_v1 == r_v2:
                # print("rot, case C - as odd dynamic")
                add_as_dynamic()
                # TODO: make warning
                line = "bleh"
                logger.warn(
                    f"ANIM_rotate"
                    f"    {Vector(c for c in dxyz)}"
                    f"    {r1} {r2}"
                    f"    {v1} {v2}"
                    f"    {path}"
                    f"\nnon line {line} has different rotation but the same dataref values - it is malformed."
                    f"Fix {self._anim_intermediate_stack[-1].intermediate_datablock}"
                )
            elif r_r1 != r_r2 and r_v1 != r_v2:
                # print("rot, case D - dynamic")
                add_as_dynamic()
        else:
            assert False, f"{directive} is not supported yet"

    def finalize_intermediate_blocks(self) -> Set[str]:
        """The last step after parsing, converting
        data to intermediate structures, clean up and error checking.

        Returns a set with FINISHED or CANCELLED, matching the returns of bpy
        operators
        """

        def reparent_children_to_new_block(
            current_parent_block: IntermediateDatablock,
            new_parent_block: IntermediateDatablock,
        ):
            for child in current_parent_block.children:
                child.datablock_info.parent_info.parent = (
                    new_parent_block.datablock_info.name
                )
            current_parent_block.children.clear()

        # Since we're using root collections mode, our INTER_ROOT empty datablock isn't made
        # and we pretend its a collection.
        blocks_rem_itr = islice(self._blocks, 1, len(self._blocks))
        while True:
            try:
                intermediate_block = next(blocks_rem_itr)
            except StopIteration:
                break
            else:
                intermediate_name = intermediate_block.datablock_info.name
                intermediate_block_type = intermediate_block.datablock_type
                intermediate_parent = intermediate_block.parent
                if intermediate_block.parent == "INTER_ROOT":
                    intermediate_block.datablock_info.parent_info = None
                intermediate_parent_info = intermediate_block.datablock_info.parent_info

            print(
                f"Deciding {intermediate_block.name}" f", parent {intermediate_parent}"
            )

            if intermediate_block_type == "EMPTY":
                # Remember, we only make empties to store animations so no try needed here

                def optimize_empty_chain(
                    in_block: IntermediateDatablock,
                    searching_itr: Iterator[IntermediateDatablock],
                ) -> Tuple[IntermediateDatablock, Iterator[IntermediateDatablock]]:
                    """
                    Cleans and optimizes IntermediateDatablocks to produce the final blocks to be created.

                    Returns next block to be created and an iterator to keep searching.

                    Current optimizations
                    Optimization                   | Requires...                                      | next_block
                    -------------------------------|--------------------------------------------------|-----------
                    merge_dref_trans_table         | is_in_block_loc_anim and is_next_block_loc_anim  |
                    add_trans_table                | both loc_anim, same rotation dref values         |
                    merge_orthogonal_rotation_axis | both rot_anim, same xp_dataref.rotation_values   | reparent children
                    take_next_block_rotations      | not in_block rot_anim, is_next_block_rot_anim    | reparent children
                    # merge_show_hide_animations   | not (is_loc_anim or is_rot_anim)                 | reparent children
                    - For the same dataref path and values, 3 orthogonal axis in a row are merged
                    - Duplicate location lists, rotations, and show/hides overwrite previous values
                    - Sequential ANIM_show/hides are merged
                    - TRIS take animations from parent empties, reducing parents

                    Arbitrary rotation axis are not supported (anywhere), locations and rotations even for the same dataref path and values are not skipped

                    Not Optimized (Yet!)
                    - Optimize out duplicate Show/Hide
                    - Sequential Axis Angle dynamic rotations with the same axis and dataref are merged into one

                    TODO Algorithms
                    - Don't reduce locations when locations are different but dataref values are same.
                    This requires user attention to fix
                    """
                    i = -1
                    while True:
                        in_block_type = in_block.datablock_type
                        in_block_animation = in_block.transform_animation
                        in_block_dataref = in_block_animation.xp_dataref
                        in_block_path = in_block_dataref.path
                        is_in_block_loc_anim = bool(in_block_animation.locations)
                        is_in_block_rot_anim = bool(in_block_animation.rotations)
                        i += 1
                        searching_itr, peek_next_block_itr = itertools.tee(
                            searching_itr
                        )

                        try:
                            next_block = next(peek_next_block_itr)
                        except StopIteration:
                            # TODO: Wait! What about self optimizations!
                            # No next block, nothing to accumulate
                            break
                        else:
                            next_name = next_block.name
                            print("next name ", next_name)
                            next_block_type = next_block.datablock_type
                            next_block_parent = next_block.parent
                            next_show_hide_animations = next_block.show_hide_animations
                            next_animation = next_block.transform_animation
                            try:
                                next_dataref = next_animation.xp_dataref
                                next_block_path = next_dataref.path
                                is_next_block_loc_anim = bool(next_animation.locations)
                                is_next_block_rot_anim = bool(next_animation.rotations)
                            except AttributeError:
                                next_dataref = None
                                next_block_path = None
                                is_next_block_loc_anim = False
                                is_next_block_rot_anim = False

                            if next_block_type == "MESH":
                                # TODO: Needs unit test showing replacement happens only with 1 child mesh
                                # multiple child meshes or mixed child meshes and empties doesn't work
                                if len(in_block.children) == 1:
                                    next_block.transform_animation = copy.copy(
                                        in_block.transform_animation
                                    )
                                    next_block.show_hide_animations = copy.copy(
                                        in_block.show_hide_animations
                                    )
                                    next_block.datablock_info.parent_info = copy.copy(
                                        in_block.datablock_info.parent_info
                                    )
                                return next_block, peek_next_block_itr
                            elif (
                                next_block_type == "EMPTY"
                                and in_block_path == next_block_path
                            ):
                                assert "" not in {
                                    in_block_path,
                                    next_block_path,
                                }, "EMPTY cannot have no dataref"
                                # WHEN DO WE SKIP THEN NEXT BLOCK?
                                assert (
                                    next_block.is_animated
                                ), f"{next_name} is EMPTY and must have animations"

                                def merge_dref_trans_table() -> IntermediateDatablock:
                                    """
                                    Merges the translation tables of in_block and next_block,
                                    returning an altered in_block and reparenting next_block's children
                                    to in_block

                                    Covers cases like

                                    ANIM_trans VecA VecB   0 1  dref1
                                    ANIM_trans VecC VecD   3 4  dref1
                                    ANIM_trans VecE VecF   -2 2 dref1
                                    TRIS 3 3

                                    dref1, 6 frames
                                    Frame | Value | Vector
                                    ------|-------|-------
                                    1     | -2    | VecE
                                    2     | 0     | VecA
                                    3     | 1     | VecB
                                    4     | 2     | VecF
                                    5     | 3     | VecC
                                    6     | 4     | VecD

                                    This is not necissarily the end of optimizations. In this example TRIS gets this table
                                    """
                                    merged_locations = collections.defaultdict(list)
                                    for location, dref_value in itertools.chain(
                                        in_block_animation.locations,
                                        next_animation.locations,
                                    ):
                                        r_location = round_vec(
                                            location, PRECISION_KEYFRAME
                                        )
                                        # if
                                        # merged_locations[round_vec(location, PRECISION_KEYFRAME)].append(dref_value

                                if is_in_block_loc_anim and is_next_block_loc_anim:
                                    # TODO:
                                    # in_block = merge_dref_trans_table()
                                    # searching_itr = peek_next_block_itr
                                    pass

                                def add_overlaping_tables():
                                    """

                                    ANIM_trans    VecA VecB   0 1 dref1
                                    ANIM_trans    VecC VecD   0 1 dref1
                                    ANIM_trans_begin dref1
                                        ANIM_trans 0  VecE
                                        ANIM_trans 2 VecF
                                    ANIM_trans_end

                                    In this case a new table is produced
                                    ANIM_trans    VecA+VecC VecB+VecD    0 1 dref1
                                    ANIM_trans_begin dref1
                                        ANIM_trans 0 VecA+VecC+VecE
                                        ANIM_trans 1 VecB+VecD
                                        ANIM_trans 2 VecF
                                    ANIM_trans_end
                                    """
                                    pass

                                # TODO: Assumes dataref ranges are the same
                                def merge_orthogonal_rotation_axis() -> IntermediateDatablock:
                                    print("merge orthogonal axis")
                                    """
                                    Attempts to merge any mergable rotations of the next_block into
                                    the in_block. Raises ValueError if next_block has nothing to merge.

                                    Assumes that the dataref ranges are the same
                                    """
                                    merge_count = 0
                                    rotations = in_block.transform_animation.rotations
                                    for (
                                        axis,
                                        degrees,
                                    ) in next_animation.rotations.items():
                                        is_axis_aligned = is_vector_axis_aligned(axis)

                                        already_used = any(
                                            round_vec(axis, PRECISION_KEYFRAME)
                                            == round_vec(vec, PRECISION_KEYFRAME)
                                            for vec in rotations
                                        )
                                        # print("is_axis_aligned:", is_axis_aligned)
                                        # print("already_used:", already_used)

                                        if is_axis_aligned and not already_used:
                                            # print("merging: ", axis)
                                            in_block_animation.rotations[axis] = degrees
                                            merge_count += 1
                                        else:
                                            # print("not merging: ", axis)
                                            pass

                                    if merge_count:
                                        reparent_children_to_new_block(
                                            next_block,
                                            in_block,
                                        )
                                    else:
                                        raise ValueError

                                    return in_block

                                if is_in_block_rot_anim and is_next_block_rot_anim:
                                    print(
                                        " rea if is_in_block_rot_anim and is_next_block_rot_anim:"
                                    )
                                    # First we see if we can do our special extra
                                    # smart merge_orthogonal_rotation_axis merge,
                                    # Otherwise we just copy and reparent the next block's
                                    try:
                                        if (
                                            in_block_animation.xp_dataref.rotation_values
                                            == next_animation.xp_dataref.rotation_values
                                        ):
                                            in_block = merge_orthogonal_rotation_axis()
                                            searching_itr = peek_next_block_itr
                                        else:
                                            raise ValueError
                                    except ValueError:
                                        pass

                                def take_next_block_rotations():
                                    in_block_animation.rotations = copy.copy(
                                        next_animation.rotations
                                    )
                                    in_block_animation.xp_dataref.rotation_values = (
                                        copy.copy(
                                            next_animation.xp_dataref.rotation_values
                                        )
                                    )
                                    reparent_children_to_new_block(next_block, in_block)

                                    return in_block

                                if (
                                    not in_block_animation.is_animated_rotation
                                    and in_block_dataref.rotation_values
                                    == next_dataref.rotation_values
                                ):
                                    # TODO: What the heck is this?
                                    in_block = take_next_block_rotations()
                                    searching_itr = peek_next_block_itr

                                # Merge Show/Hides
                                def merge_show_hide_animations():
                                    """
                                    If the next EMPTY is simply a show/hide,
                                    absorb it's animations
                                    """
                                    for next_anim in (
                                        next_anim
                                        for next_anim in next_show_hide_animations
                                        if next_anim.anim_type
                                        in {ANIM_TYPE_SHOW, ANIM_TYPE_HIDE}
                                    ):
                                        print(
                                            f"{in_block.name} from show/hide from {next_name}"
                                        )
                                        in_block.show_hide_animations.append(next_anim)

                                if next_show_hide_animations:
                                    show_hide_count = len(in_block.show_hide_animations)
                                    merge_show_hide_animations()
                                    if (
                                        len(in_block.show_hide_animations)
                                        - show_hide_count
                                    ):
                                        reparent_children_to_new_block(
                                            next_block,
                                            in_block,
                                        )
                                        searching_itr = peek_next_block_itr
                                # We have no more optimizations to apply to two blocks with
                                # the same dataref paths, move iterator
                                # next(searching_itr)
                                print("normal searching)itr = peeknextblock")
                            # --- end next empty with same dataref -------------
                            elif (
                                next_block_type == "EMPTY"
                                and in_block_path != next_block_path
                            ):
                                # Different dataref = search complete.
                                # outer loop will advance itr
                                return (in_block, searching_itr)

                            else:
                                assert False, f"{next_block_type} is not yet supported"

                            # What we need: Big if statement to collect optimizations to run, in what order, what should be done to the intermediate block, if you're getting rid of it who to reparent to, what shuold happen to the next block. We need a big ordered table.

                            # end if False
                    # end while
                    return (in_block, searching_itr)

                # end def optimize_empty_chain
                print(f"IN {intermediate_block.name}")
                out_block = intermediate_block
                # out_block, blocks_rem_itr = optimize_empty_chain(
                # intermediate_block, blocks_rem_itr
                # )
                #                print(
                #                    "location values",
                #                    out_block.transform_animation.xp_dataref.location_values,
                #                )
                #                print(
                #                    "rotation values",
                #                    out_block.transform_animation.xp_dataref.rotation_values,
                #                )

                print(
                    f"OUT {out_block.name}, parent: {out_block.parent}, type: {out_block.datablock_type}"
                )
            elif intermediate_block_type == "MESH":
                out_block = intermediate_block

            def fill_in_eulers(
                block_to_fill: IntermediateDatablock,
            ) -> Tuple[Dict[Vector, List[float]], str]:
                """
                Returns Euler rotations as a complete 3 entry dictionary, any holes filled in,
                and its accompanying rotation_mode.

                block_to_fill must be animated for rotation with
                axis-aligned vectors only.
                """

                degrees = [0.0] * len(
                    block_to_fill.transform_animation.xp_dataref.rotation_values
                )
                filled_rotations = {
                    "X": [Vector((1, 0, 0)).freeze(), degrees.copy()],
                    "Y": [Vector((0, 1, 0)).freeze(), degrees.copy()],
                    "Z": [Vector((0, 0, 1)).freeze(), degrees.copy()],
                }

                in_order = ""
                for (
                    axis,
                    degrees,
                ) in block_to_fill.transform_animation.rotations.items():
                    r_axis = tuple(
                        map(lambda c: bool(round(c, PRECISION_KEYFRAME)), axis)
                    )
                    axis_label = ["X", "Y", "Z"][r_axis.index(True)]
                    filled_rotations[axis_label] = [
                        axis.freeze(),
                        degrees,
                    ]
                    in_order += axis_label
                # If not all axis of an apparent Euler rotation
                # were given in the OBJ, we fix the rotation mode
                # based on some assumptions of what would have been good for
                # X-Plane
                if len(in_order) == 1:
                    corrected_order = "ZYX"
                elif len(in_order) == 2:
                    corrected_order = {
                        "XY": "XYZ",
                        "YZ": "XYZ",
                        "XZ": "XYZ",
                        "YX": "ZYX",
                        "ZY": "ZYX",
                        "ZX": "ZYX",
                    }[in_order]

                elif len(in_order) == 3:
                    corrected_order = in_order

                # Any good exporter would take XYZ and write
                # it as X-Plane's ZYX. The importer goes in
                # reverse
                rotation_mode = {
                    "XYZ": "ZYX",
                    "YXZ": "ZXY",
                    "XZY": "YZX",
                    "ZXY": "YXZ",
                    "YZX": "XZY",
                    "ZYX": "XYZ",
                }[corrected_order]

                # Sorting the dictionary is added only as a debugging convenience
                return (
                    {
                        axis: degrees
                        for axis_label, (axis, degrees) in sorted(
                            filled_rotations.items(),
                            key=lambda kv: rotation_mode.index(kv[0]),
                        )
                    },
                    rotation_mode,
                )

            try:
                is_all_euler = out_block.transform_animation.rotations and all(
                    is_vector_axis_aligned(axis)
                    for axis in out_block.transform_animation.rotations
                )
            except AttributeError:  # No transform_animation
                pass
            else:
                if is_all_euler:
                    (
                        out_block.transform_animation.rotations,
                        out_block.datablock_info.rotation_mode,
                    ) = fill_in_eulers(out_block)

            if out_block.datablock_type == "EMPTY":
                ob = test_creation_helpers.create_datablock_empty(
                    out_block.datablock_info,
                    empty_display_size=0.05,
                )
            elif out_block.datablock_type == "MESH":
                try:
                    ob = out_block.build_mesh(self.vt_table)
                except ValueError:
                    ob = None
                else:
                    if self.texture:
                        test_creation_helpers.set_material(
                            ob, "Material", texture_image=self.texture
                        )

            if ob:
                ob.matrix_local = out_block.bake_matrix.copy()
                bpy.context.view_layer.update()

                ob.rotation_mode = out_block.rotation_mode

                try:
                    out_block.transform_animation.apply_animation(ob)
                except AttributeError:  # No transform animation
                    pass

                for animation in out_block.show_hide_animations:
                    animation.apply_animation(ob)

        # end while for searching remaining blocks
        # TODO: Unit test, and what about a bunch of animations that get optimized out with not TRIS blocks?
        # Put this later
        if not bpy.data.objects:
            logger.warn(".obj had no real datablocks to create")
            return {"CANCELLED"}

        bpy.context.scene.frame_set(1)
        return {"FINISHED"}

    @property
    def _top_animation(self) -> Optional[IntermediateAnimation]:
        try:
            return self._anim_intermediate_stack[-1].animation
        except IndexError:
            return None

    @_top_animation.setter
    def _top_animation(self, value: IntermediateAnimation) -> None:
        self._anim_intermediate_stack[-1].animation = value

    @property
    def _top_intermediate_datablock(self) -> Optional[IntermediateDatablock]:
        try:
            return self._anim_intermediate_stack[-1].intermediate_datablock
        except IndexError:
            return None

    @_top_intermediate_datablock.setter
    def _top_intermediate_datablock(self, value: IntermediateDatablock) -> None:
        self._anim_intermediate_stack[-1].intermediate_datablock = value

    @property
    def _top_dataref(self) -> Optional[IntermediateDataref]:
        return self._top_animation.xp_dataref

    @_top_dataref.setter
    def _top_dataref(self, value: IntermediateDataref) -> None:
        self._top_animation.xp_dataref = value

    def _next_empty_name(self) -> str:
        return (
            f"ImpEmpty."
            f"{sum(1 for block in self._blocks if block.datablock_type == 'EMPTY'):03}"
            f"_{hex(hash(self.root_collection.name))[2:6]}"
            f"_{random.randint(0,100000)}"
        )

    def _next_object_name(self) -> str:
        return (
            f"ImpMesh."
            f"{sum(1 for block in self._blocks if block.datablock_type == 'MESH'):03}"
            f"_{hex(hash(self.root_collection.name))[2:6]}"
            f"_{random.randint(0,100000)}"
        )
